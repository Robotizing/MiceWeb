#!/usr/bin/env bash
###############################################################################
#
#                                                
# 88b           d88  88                           
# 888b         d888  ""                           
# 88`8b       d8'88                               
# 88 `8b     d8' 88  88   ,adPPYba,   ,adPPYba,   
# 88  `8b   d8'  88  88  a8"     ""  a8P_____88   
# 88   `8b d8'   88  88  8b          8PP"""""""   
# 88    `888'    88  88  "8a,   ,aa  "8b,   ,aa   
# 88     `8'     88  88   `"Ybbd8"'   `"Ybbd8"'   
#                                                
#                                                
#                                                
# I8,        8        ,8I            88           
# `8b       d8b       d8'            88           
#  "8,     ,8"8,     ,8"             88           
#   Y8     8P Y8     8P   ,adPPYba,  88,dPPYba,   
#   `8b   d8' `8b   d8'  a8P_____88  88P'    "8a  
#    `8a a8'   `8a a8'   8PP"""""""  88       d8  
#     `8a8'     `8a8'    "8b,   ,aa  88b,   ,a8"  
#      `8'       `8'      `"Ybbd8"'  8Y"Ybbd8"'   
#                                                
#
# Depends on:
#  https://docs.ipfs.io/install/command-line/
#  https://www.gnu.org/software/wget/
#  https://stedolan.github.io/jq/download/
#  https://github.com/mgdm/htmlq/
#  https://github.com/ImportTaste/wayback-machine-downloader
#  https://git-scm.com/downloads
#  https://www.gnu.org/software/bash/
#
# MiceWeb: https://github.com/Robotizing/MiceWeb
#
# Copyright (c) 2022 Robotizing Networks â€¢Â robotizing.net
###############################################################################

# Return value of a pipeline is the value of the last (rightmost) command to
# exit with a non-zero status, or zero if all commands in the pipeline exit
# successfully.
set -o pipefail

# Set $IFS to only newline and tab.
#
# http://www.dwheeler.com/essays/filenames-in-shell.html
IFS=$'\n\t'

###############################################################################
# Globals
###############################################################################

# $_ME
#
# This program's basename.
_ME="$(basename "${0}")"

# $_VERSION
#
# Manually set this to to current version of the program. Adhere to the
# semantic versioning specification: http://semver.org
_VERSION="0.3"

# $DEFAULT_SUBCOMMAND
#
# The subcommand to be run by default, when no subcommand name is specified.
# If the environment has an existing $DEFAULT_SUBCOMMAND set, then that value
# is used.
DEFAULT_SUBCOMMAND="${DEFAULT_SUBCOMMAND:-help}"

###############################################################################
# Debug
###############################################################################

# _debug()
#
# Usage:
#   _debug <command> <options>...
#
# Description:
#   Execute a command and print to standard error. The command is expected to
#   print a message and should typically be either `echo`, `printf`, or `cat`.
#
# Example:
#   _debug printf "Debug info. Variable: %s\\n" "$0"
__DEBUG_COUNTER=0
_debug() {
  if ((${_USE_DEBUG:-0}))
  then
    __DEBUG_COUNTER=$((__DEBUG_COUNTER+1))
    {
      # Prefix debug message with "bug (U+1F41B)"
      printf "ðŸ›  %s " "${__DEBUG_COUNTER}"
      "${@}"
      printf "â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•\\n"
    } 1>&2
  fi
}

###############################################################################
# Error Messages
###############################################################################

# _exit_1()
#
# Usage:
#   _exit_1 <command>
#
# Description:
#   Exit with status 1 after executing the specified command with output
#   redirected to standard error. The command is expected to print a message
#   and should typically be either `echo`, `printf`, or `cat`.
_exit_1() {
  {
    printf "%s " "$(tput setaf 1)!$(tput sgr0)"
    "${@}"
  } 1>&2
  exit 1
}

# _warn()
#
# Usage:
#   _warn <command>
#
# Description:
#   Print the specified command with output redirected to standard error.
#   The command is expected to print a message and should typically be either
#   `echo`, `printf`, or `cat`.
_warn() {
  {
    printf "%s " "$(tput setaf 1)!$(tput sgr0)"
    "${@}"
  } 1>&2
}

###############################################################################
# Utility Functions
###############################################################################

# _command_exists()
#
# Usage:
#   _command_exists <name>
#
# Exit / Error Status:
#   0 (success, true) If a command with <name> is defined in the current
#                     environment.
#   1 (error,  false) If not.
#
# Information on why `hash` is used here:
# http://stackoverflow.com/a/677212
_command_exists() {
  command hash "${1}" 2>/dev/null
}

# _contains()
#
# Usage:
#   _contains <query> <list-item>...
#
# Exit / Error Status:
#   0 (success, true)  If the item is included in the list.
#   1 (error,  false)  If not.
#
# Examples:
#   _contains "${_query}" "${_list[@]}"
_contains() {
  local _query="${1:-}"
  shift

  if [[ -z "${_query}"  ]] ||
     [[ -z "${*:-}"     ]]
  then
    return 1
  fi

  for __element in "${@}"
  do
    [[ "${__element}" == "${_query}" ]] && return 0
  done

  return 1
}

# _join()
#
# Usage:
#   _join <delimiter> <list-item>...
#
# Description:
#   Print a string containing all <list-item> arguments separated by
#   <delimeter>.
#
# Example:
#   _join "${_delimeter}" "${_list[@]}"
#
# More information:
#   https://stackoverflow.com/a/17841619
_join() {
  local _delimiter="${1}"
  shift
  printf "%s" "${1}"
  shift
  printf "%s" "${@/#/${_delimiter}}" | tr -d '[:space:]'
}

# _blank()
#
# Usage:
#   _blank <argument>
#
# Exit / Error Status:
#   0 (success, true)  If <argument> is not present or null.
#   1 (error,  false)  If <argument> is present and not null.
_blank() {
  [[ -z "${1:-}" ]]
}

# _interactive_input()
#
# Usage:
#   _interactive_input
#
# Exit / Error Status:
#   0 (success, true)  If the current input is interactive (eg, a shell).
#   1 (error,  false)  If the current input is stdin / piped input.
_interactive_input() {
  [[ -t 0 ]]
}

# _piped_input()
#
# Usage:
#   _piped_input
#
# Exit / Error Status:
#   0 (success, true)  If the current input is stdin / piped input.
#   1 (error,  false)  If the current input is interactive (eg, a shell).
_piped_input() {
  ! _interactive_input
}

###############################################################################
# describe
###############################################################################

# describe()
#
# Usage:
#   describe <name> <description>
#   describe --get <name>
#
# Options:
#   --get  Print the description for <name> if one has been set.
#
# Examples:
# ```
#   describe "list" <<HEREDOC
# Usage:
#   ${_ME} list
#
# Description:
#   List items.
# HEREDOC
#
# describe --get "list"
# ```
#
# Set or print a description for a specified subcommand or function <name>. The
# <description> text can be passed as the second argument or as standard input.
#
# To make the <description> text available to other functions, `describe()`
# assigns the text to a variable with the format `$___describe_<name>`.
#
# When the `--get` option is used, the description for <name> is printed, if
# one has been set.
#
# NOTE:
#
# The `read` form of assignment is used for a balance of ease of
# implementation and simplicity. There is an alternative assignment form
# that could be used here:
#
# var="$(cat <<'HEREDOC'
# some message
# HEREDOC
# )
#
# However, this form appears to require trailing space after backslases to
# preserve newlines, which is unexpected. Using `read` simply requires
# escaping backslashes, which is more common.
describe() {
  _debug printf "describe() \${*}: %s\\n" "$@"
  [[ -z "${1:-}" ]] && _exit_1 printf "describe(): <name> required.\\n"

  if [[ "${1}" == "--get" ]]
  then # get ------------------------------------------------------------------
    [[ -z "${2:-}" ]] &&
      _exit_1 printf "describe(): <description> required.\\n"

    local _name="${2:-}"
    local _describe_var="___describe_${_name}"

    if [[ -n "${!_describe_var:-}" ]]
    then
      printf "%s\\n" "${!_describe_var}"
    else
      printf "No additional information for \`%s\`\\n" "${_name}"
    fi
  else # set ------------------------------------------------------------------
    if [[ -n "${2:-}" ]]
    then # argument is present
      read -r -d '' "___describe_${1}" <<HEREDOC
${2}
HEREDOC
    else # no argument is present, so assume piped input
      # `read` exits with non-zero status when a delimeter is not found, so
      # avoid errors by ending statement with `|| true`.
      read -r -d '' "___describe_${1}" || true
    fi
  fi
}

###############################################################################
# Program Option Parsing
#
# NOTE: The `getops` builtin command only parses short options and BSD `getopt`
# does not support long arguments (GNU `getopt` does), so use custom option
# normalization and parsing.
#
# For a pure bash `getopt` function, try pure-getopt:
#   https://github.com/agriffis/pure-getopt
#
# More info:
#   http://wiki.bash-hackers.org/scripting/posparams
#   http://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html
#   http://stackoverflow.com/a/14203146
#   http://stackoverflow.com/a/7948533
#   https://stackoverflow.com/a/12026302
#   https://stackoverflow.com/a/402410
###############################################################################

# Normalize Options ###########################################################

# Source:
#   https://github.com/e36freak/templates/blob/master/options

# Iterate over options, breaking -ab into -a -b and --foo=bar into --foo bar
# also turns -- into --endopts to avoid issues with things like '-o-', the '-'
# should not indicate the end of options, but be an invalid option (or the
# argument to the option, such as wget -qO-)
unset options
# while the number of arguments is greater than 0
while ((${#}))
do
  case "${1}" in
    # if option is of type -ab
    -[!-]?*)
      # loop over each character starting with the second
      for ((i=1; i<${#1}; i++))
      do
        # extract 1 character from position 'i'
        c="${1:i:1}"
        # add current char to options
        options+=("-${c}")
      done
      ;;
    # if option is of type --foo=bar, split on first '='
    --?*=*)
      options+=("${1%%=*}" "${1#*=}")
      ;;
    # end of options, stop breaking them up
    --)
      options+=(--endopts)
      shift
      options+=("${@}")
      break
      ;;
    # otherwise, nothing special
    *)
      options+=("${1}")
      ;;
  esac

  shift
done
# set new positional parameters to altered options. Set default to blank.
set -- "${options[@]:-}"
unset options

# Parse Options ###############################################################

_SUBCOMMAND=""
_SUBCOMMAND_ARGUMENTS=()
_USE_DEBUG=0

while ((${#}))
do
  __opt="${1}"

  shift

  case "${__opt}" in
    -h|--help)
      _SUBCOMMAND="help"
      ;;
    --debug)
      _USE_DEBUG=1
      ;;
    *)
      # The first non-option argument is assumed to be the subcommand name.
      # All subsequent arguments are added to $_SUBCOMMAND_ARGUMENTS.
      if [[ -n "${_SUBCOMMAND}" ]]
      then
        _SUBCOMMAND_ARGUMENTS+=("${__opt}")
      else
        _SUBCOMMAND="${__opt}"
      fi
      ;;
  esac
done

###############################################################################
# Main
###############################################################################

# Declare the $_DEFINED_SUBCOMMANDS array.
_DEFINED_SUBCOMMANDS=()

# _main()
#
# Usage:
#   _main
#
# Description:
#   The primary function for starting the program.
#
#   NOTE: must be called at end of program after all subcommands are defined.
_main() {
  # If $_SUBCOMMAND is blank, then set to `$DEFAULT_SUBCOMMAND`
  if [[ -z "${_SUBCOMMAND}" ]]
  then
    _SUBCOMMAND="${DEFAULT_SUBCOMMAND}"
  fi

  for __name in $(declare -F)
  do
    # Each element has the format `declare -f function_name`, so set the name
    # to only the 'function_name' part of the string.
    local _function_name
    _function_name=$(printf "%s" "${__name}" | awk '{ print $3 }')

    if ! { [[ -z "${_function_name:-}"                      ]] ||
           [[ "${_function_name}" =~ ^_(.*)                 ]] ||
           [[ "${_function_name}" == "bats_readlinkf"       ]] ||
           [[ "${_function_name}" == "describe"             ]] ||
           [[ "${_function_name}" == "shell_session_update" ]]
    }
    then
      _DEFINED_SUBCOMMANDS+=("${_function_name}")
    fi
  done

  # If the subcommand is defined, run it, otherwise return an error.
  if _contains "${_SUBCOMMAND}" "${_DEFINED_SUBCOMMANDS[@]:-}"
  then
    # Pass all comment arguments to the program except for the first ($0).
    ${_SUBCOMMAND} "${_SUBCOMMAND_ARGUMENTS[@]:-}"
  else
    _exit_1 printf "Unknown subcommand: %s\\n" "${_SUBCOMMAND}"
  fi
}

# --------------------------------------------------------------------- functions

_addToHistory() {
	mkdir --parents "$HOME/.miceweb"
	local DT=$(export TZ=GMT ; date '+%Y-%m-%d GMT %H:%M:%S')
	printf "%s\t%s\n" "$DT" "$1" >> "$HOME/.miceweb/history.txt"
}

_check_free_space_for_temp() {
	if [ $(_free_space $(dirname $(mktemp -u 2>/dev/null || mktemp -u -t 'mytmpdir'))) -gt 102400 ]; then
		return 0
	else
		return 1
	fi
}

_check_url() {
	local URL="$1"
	if [[ "$URL" != http://* && "$URL" != https://* && "$URL" != ipns://* && "$URL" != ipfs://* && "$URL" != ftp://* && "$URL" != ftps://* ]]; then
		return 1
	else
		return 0
	fi
}

_free_space() {
	echo $(df -Pk $1 | sed 1d | grep -v used | awk '{ print $4 "\t" }')
}

_has_url_fragment() {
	local URL="$1"
	if [[ "$URL" =~ ['#'] ]]; then
		return 0;
	else
		return 1;
	fi
}

_hash() {
	_hash_string "$(_url_but_fragment "$1")"
}

_hash_string() {
	local HASH=$(printf '%s' "$1" | sha1sum 2>/dev/null | cut -d' ' -f1)
	if [[ "$HASH" != "" ]]; then
		echo "$HASH"
	else
		HASH=$(printf '%s' "$1" | openssl sha1 -r 2>/dev/null | cut -d' ' -f1)
		if [[ "$HASH" != "" ]]; then
			echo "$HASH"
		else
			HASH=$(printf '%s' "$1" | shasum -a 1 2>/dev/null | cut -d' ' -f1)
			if [[ "$HASH" != "" ]]; then
				echo "$HASH"
			else
				_exit_1 printf "Installed sha1sum, shasum or openssl is required for MiceWeb\n"
			fi
		fi
	fi
}

# https://www.rfc-editor.org/rfc/rfc3986#appendix-B
#
readonly URI_REGEX='^(([^:/?#]+):)?(//((([^:/?#]+)@)?([^:/?#]+)(:([0-9]+))?))?(/([^?#]*))(\?([^#]*))?(#(.*))?'
#                    â†‘â†‘            â†‘  â†‘â†‘â†‘            â†‘         â†‘ â†‘            â†‘ â†‘        â†‘  â†‘        â†‘ â†‘
#                    |2 scheme     |  ||6 userinfo   7 host    | 9 port       | 11 rpath |  13 query | 15 fragment
#                    1 scheme:     |  |5 userinfo@             8 :â€¦           10 path    12 ?â€¦       14 #â€¦
#                                  |  4 authority
#                                  3 //â€¦
_parse_scheme () {
    [[ "$@" =~ $URI_REGEX ]] && echo "${BASH_REMATCH[2]}"
}
_parse_authority () {
    [[ "$@" =~ $URI_REGEX ]] && echo "${BASH_REMATCH[4]}"
}
_parse_user () {
    [[ "$@" =~ $URI_REGEX ]] && echo "${BASH_REMATCH[6]}"
}
_parse_host () {
    [[ "$@" =~ $URI_REGEX ]] && echo "${BASH_REMATCH[7]}"
}
_parse_port () {
    [[ "$@" =~ $URI_REGEX ]] && echo "${BASH_REMATCH[9]}"
}
_parse_path () {
    [[ "$@" =~ $URI_REGEX ]] && echo "${BASH_REMATCH[10]}"
}
_parse_rpath () {
    [[ "$@" =~ $URI_REGEX ]] && echo "${BASH_REMATCH[11]}"
}
_parse_query () {
    [[ "$@" =~ $URI_REGEX ]] && echo "${BASH_REMATCH[13]}"
}
_parse_fragment () {
    [[ "$@" =~ $URI_REGEX ]] && echo "${BASH_REMATCH[15]}"
}

_print_hyperlink() {
	local URL="$1"
	local URLTEXT="$2"
	if [[ "$URLTEXT" == "" ]]; then
		URLTEXT="$URL"
	fi
	printf '\e]8;;%s\e\\%s\e]8;;\e\\' "$URL" "$URLTEXT"
}
_print_with_hyperlink() {
	local PREFIX="$1"
	local URL="$2"
	local SUFFIX="$3"
	printf '%s' "$PREFIX"
	_print_hyperlink "$URL"
	printf '%s\n' "$SUFFIX"
}

_random_value() {
	local chars=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
	for i in {1..32} ; do
		echo -n "${chars:RANDOM%${#chars}:1}"
	done
	echo
}

_reprovidingWarning() {
	local REPROVIDING=$(ipfs config Reprovider.Strategy)
	if [[ "$REPROVIDING" == "all" ]]; then
		>&2 echo "Warning: the reprovider announces all IPFS data including the MiceWeb Library,"
		>&2 echo " run 'ipfs config Reprovider.Strategy pinned'"
		>&2 echo " to announce only pinned data, see also"
		>&2 echo " https://github.com/ipfs/go-ipfs/blob/master/docs/config.md#reproviderstrategy"
	fi
}

_save_archived() {
	type -P wayback_machine_downloader &>/dev/null && ISINST=1 || ISINST=0
	if [ $ISINST -eq 0 ]
	then
		>&2 echo "Error: wayback_machine_downloader is not installed"
		return 127
	fi
	type -P jq &>/dev/null && ISINST=1 || ISINST=0
	if [ $ISINST -eq 0 ]
	then
		>&2 _print_with_hyperlink "Error: jq is not installed (seeing " "https://stedolan.github.io/jq/download/" ")"
		return 127
	fi
	local RET=1
	for I in $(wayback_machine_downloader -s -e -l "$1" 2>/dev/null | jq --raw-output '.. | .timestamp? | strings' | tail -n1); do
		local SUBDIR="${I:0:8}GMT${I:8:6}-archive"
		ipfs files ls /$SAVE_MFS_ADDR/$SUBDIR &>/dev/null
		if [ $? -ne 0 ]; then
			_wget "https://web.archive.org/web/$I/$1" --cut-dirs=1
			if [ $? -eq 0 ]; then
				RET=0
			fi
		else
			>&2 echo "$SUBDIR is already downloaded"
		fi
	done
	return $RET
}
_save_ipfs() {
	local MAIN=$(echo "$1" | awk -F/ '{print $1}')
	local ADDR=$(ipfs resolve --timeout=60s $MAIN)
	if [[ "$ADDR" != "" ]]; then
		local DT=$(export TZ=GMT ; date '+%Y%m%dGMT%H%M%S')
		local SUBDIR="$DT-ipfs"
		ipfs files ls /$SAVE_MFS_ADDR/$SUBDIR &>/dev/null
		if [ $? -ne 0 ]; then
			local GATEWAY=$(ipfs config Addresses.Gateway)
			# TODO: use ipfs.io when gateway is not available (output a warning)
			if [ $? -eq 0 ]; then
				_wget "http://127.0.0.1:${GATEWAY##*/}/ipfs/$1" --cut-dirs=1
				return $?
			fi
		else
			>&2 echo "$SUBDIR exists"
			return 0
		fi
	fi
	return 1
}
_save_ipns() {
	local DOMAIN=$(echo "$1" | awk -F/ '{print $1}')
	local ADDR=$(ipfs name resolve --recursive=true --timeout=60s $DOMAIN)
	if [[ "$ADDR" != "" ]]; then
		local DT=$(export TZ=GMT ; date '+%Y%m%dGMT%H%M%S')
		local SUBDIR="$DT-ipns"
		ipfs files ls /$SAVE_MFS_ADDR/$SUBDIR &>/dev/null
		if [ $? -ne 0 ]; then
			local GATEWAY=$(ipfs config Addresses.Gateway)
			# TODO: use ipfs.io when gateway is not available (output a warning)
			if [ $? -eq 0 ]; then
				_wget "http://127.0.0.1:${GATEWAY##*/}/ipns/$1" --cut-dirs=1 "Resolved /ipns/$DOMAIN to $ADDR"
				return $?
			fi
		else
			>&2 echo "$SUBDIR exists"
			return 0
		fi
	fi
	return 1
}
_save_wget() {
	local DT=$(export TZ=GMT ; date '+%Y%m%dGMT%H%M%S')
	local SUBDIR="$DT-wget"
	ipfs files ls /$SAVE_MFS_ADDR/$SUBDIR &>/dev/null
	if [ $? -ne 0 ]; then
		_wget $1
		if [ $? -ne 0 ]; then
			_wget $1 --torsocks
		fi
		return $?
	else
		>&2 echo "$SUBDIR exists"
		return 0
	fi
}

_similar() {
	local URL="$(_url_but_fragment "$1")"
	for I in $(_similar_but_scheme "$URL"); do
		for J in $(_similar_but_slash "$I"); do
			for K in $(_similar_concrete "$J"); do
				echo "$K"
			done
		done
	done
}
_similar_but_scheme() {
	local URL="$1"
	local host="$(_parse_host "$URL/")"
	if [[ $host == *.* ]]; then
		if [[ $URL == http://* ]]; then
			echo $URL
			echo "https://${URL#http://}"
			echo "ipns://${URL#http://}"
		elif [[ $URL == https://* ]]; then
			echo "http://${URL#https://}"
			echo $URL
			echo "ipns://${URL#https://}"
		elif [[ $URL == ipns://* ]]; then
			echo "http://${URL#ipns://}"
			echo "https://${URL#ipns://}"
			echo $URL
		elif [[ $URL == ftp://* ]]; then
			echo $URL
			echo "ftps://${URL#ftp://}"
		elif [[ $URL == ftps://* ]]; then
			echo "ftp://${URL#ftps://}"
			echo $URL
		else
			echo $URL
		fi
	else
		echo $URL
	fi
}
_similar_but_slash() {
	local URL="$1"
	local URL1="${URL%/}"
	local URL2="$URL1/"
	echo $URL1
	echo $URL2
}
_similar_concrete() {
	local URL="$1"
	local host=$(_parse_host "$URL/")
	echo $URL
	# www
	if [[ $URL == http://www.* ]]; then
		echo "http://${URL#http://www.}"
	elif [[ $URL == http://* ]]; then
		echo "http://www.${URL#http://}"
	elif [[ $URL == https://www.* ]]; then
		echo "https://${URL#https://www.}"
	elif [[ $URL == https://* ]]; then
		echo "https://www.${URL#https://}"
	fi
	# FTP
	if [[ $URL == http://ftp.* ]]; then
		echo "https://ftp.${URL#http://ftp.}"
		echo "ftp://ftp.${URL#http://ftp.}"
	elif [[ $URL == https://ftp.* ]]; then
		echo "http://ftp.${URL#https://ftp.}"
		echo "ftp://ftp.${URL#https://ftp.}"
	elif [[ $URL == ftp://ftp.* ]]; then
		echo "http://ftp.${URL#ftp://ftp.}"
		echo "https://ftp.${URL#ftp://ftp.}"
	fi
	# ZeroNet
	if [[ $URL == http://127.0.0.1:43110/raw/* ]]; then
		echo "http://127.0.0.1:43110/${URL#http://127.0.0.1:43110/raw/}"
	elif [[ $URL == http://127.0.0.1:43110/* ]]; then
		echo "http://127.0.0.1:43110/raw/${URL#http://127.0.0.1:43110/}"
	fi
	# IPFS
	if [[ $URL == ipfs://$host/* ]]; then
		if [[ $URL == ipfs://Qm* ]]; then
			local converted="$(ipfs cid format -v 1 -b base32 $host)"
			if [[ "$converted" != "" ]]; then
				echo "ipfs://$converted/${URL#ipfs://$host/}"
			fi
		elif [[ $URL == ipfs://bafy* ]]; then
			local converted="$(ipfs cid format -v 0 -b base58btc $host)"
			if [[ "$converted" != "" ]]; then
				echo "ipfs://$converted/${URL#ipfs://$host/}"
			fi
		fi
	fi
	# Habr
	if [[ $URL == https://habrahabr.ru/* ]]; then
		echo "https://habr.com/ru/${URL#https://habrahabr.ru/}"
		echo "https://habr.com/en/${URL#https://habrahabr.ru/}"
		echo "https://habr.com/${URL#https://habrahabr.ru/}"
	elif [[ $URL == https://habr.com/ru/* ]]; then
		echo "https://habrahabr.ru/${URL#https://habr.com/ru/}"
		echo "https://habr.com/en/${URL#https://habr.com/ru/}"
		echo "https://habr.com/${URL#https://habr.com/ru/}"
	elif [[ $URL == https://habr.com/en/* ]]; then
		echo "https://habrahabr.ru/${URL#https://habr.com/en/}"
		echo "https://habr.com/ru/${URL#https://habr.com/en/}"
		echo "https://habr.com/${URL#https://habr.com/en/}"
	elif [[ $URL == https://habr.com/* ]]; then
		echo "https://habrahabr.ru/${URL#https://habr.com/}"
		echo "https://habr.com/en/${URL#https://habr.com/}"
		echo "https://habr.com/ru/${URL#https://habr.com/}"
	fi
	# VK
	if [[ $URL == https://vk.com/* ]]; then
		echo "https://vkontakte.ru/${URL#https://vk.com/}"
	elif [[ $URL == https://vkontakte.ru/* ]]; then
		echo "https://vk.com/${URL#https://vkontakte.ru/}"
	fi
	# YouTube
	if [[ $URL == https://youtu.be/* ]]; then
		echo "https://www.youtube.com/watch?v=${URL#https://youtu.be/}"
	elif [[ $URL == https://www.youtube.com/watch?v=* ]]; then
		echo "https://youtu.be/${URL#https://www.youtube.com/watch?v=}"
	fi
}
#similar() {
#	_similar "$1"
#}

_subcommands() {
  if [[ "${1:-}" == "--raw" ]]
  then
    printf "%s\\n" "${_DEFINED_SUBCOMMANDS[@]}"
  else
    printf "Available subcommands:\\n"
    printf "  %s\\n" "${_DEFINED_SUBCOMMANDS[@]}"
  fi
}

_upgrade() {
	local TESTHASH1=$(_hash "test")
	if [[ "$TESTHASH1" != "a94a8fe5ccb19ba61c4c0873d391e987982fbbd3" ]]; then
		exit 1
	fi
	local VERTXT="/MiceWeb/attributes.txt"
	local VER=$(ipfs files read /$VERTXT 2>/dev/null | sed -n 2p)
	if [[ $VER == "" ]]; then
		local TESTHASH2="$(echo -n "test" | ipfs add --only-hash --quieter --cid-version=0)"
		if [[ "$TESTHASH2" != "QmRf22bZar3WKmojipms22PkXH1MZGmvsqzQtuSvQE3uhm" ]]; then
			_exit_1 _print_with_hyperlink "Installed " "https://github.com/ipfs/go-ipfs" " is required for MiceWeb"
		fi
	fi
	local APPVER="v.${_VERSION}"
	if [[ $APPVER != $VER ]]; then
		if [[ $VER == "" ]]; then
			if ! ipfs files ls //MiceWeb &>/dev/null; then
				ipfs files mkdir //MiceWeb 2>/dev/null
				local VERTXTCID="$(printf "%s\n%s\n" "Library $(_random_value)" "$APPVER" | ipfs add --quieter --pin=false)"
				if ipfs files cp //ipfs/$VERTXTCID /$VERTXT; then
					return 0
				else
					_exit_1 printf "Can't create the MiceWeb Library\n"
				fi
			fi
			backup >/dev/null
			ipfs files mkdir //MiceWeb/pages 2>/dev/null
			local CID="$(ipfs files stat --hash //MiceWeb/pages/)"
			if [[ "$CID" != "" ]]; then
				for I in $(ipfs files ls //MiceWeb/pages/ | grep ^page-Qm); do
					local URL=$(ipfs cat $CID/$I/URL.txt 2>/dev/null | sed -n 2p)
					if [[ "$URL" != "" ]]; then
						>&2 echo -n "Upgrading $URL..."
						local HASH=$(_hash "$URL")
						>&2 echo -n "."
						if [[ "$HASH" != "" ]]; then
							ipfs files mv //MiceWeb/pages/$I "//MiceWeb/pages/$HASH"
						fi
						>&2 echo "."
					fi
				done
				local VERTXTCID="$(printf "%s\n%s\n" "Library $(_random_value)" "v.0.2" | ipfs add --quieter --pin=false)"
				ipfs files cp //ipfs/$VERTXTCID /$VERTXT
				if [ $? -eq 0 ]; then
					>&2 echo "Upgraded the MiceWeb Library to v.0.2"
					_upgrade
					return $?
				fi
			fi
			_exit_1 printf "Can't upgrade the MiceWeb Library\n"
		else
			_vercomp "${_VERSION}" "${VER#v.}"
			if [ $? -eq 1 ]; then
				# updating to v.0.3
				backup >/dev/null
				local VERTXTCID="$(printf "%s\n%s\n" "Library $(_random_value)" "v.0.3" | ipfs add --quieter --pin=false)"
				ipfs files rm /$VERTXT
				ipfs files cp //ipfs/$VERTXTCID /$VERTXT
				if [ $? -eq 0 ]; then
					>&2 echo "Upgraded the MiceWeb Library to v.0.3"
					>&2 echo "It's recommended to run 'miceweb save urls --grep=#'"
					save urls --grep="#"
					>&2 echo ""
					return 0
				fi
				_exit_1 printf "Can't upgrade the MiceWeb Library\n"
			else
				_exit_1 printf "MiceWeb $VER+ is required to work with the current MiceWeb Library\nThe current app version is $APPVER\nRun './update.sh' in the MiceWeb repository\n"
			fi
		fi
	fi
	return 0
}

_url_but_fragment() {
	local URL="$1"
	local fragment=$(_parse_fragment "$URL")
	if _has_url_fragment "$URL"; then
		echo "${URL%#$fragment}"
	else
		echo "$URL"
	fi
}

# https://stackoverflow.com/questions/4023830/how-to-compare-two-strings-in-dot-separated-version-format-in-bash
_vercomp () {
    if [[ $1 == $2 ]]
    then
        return 0
    fi
    local IFS=.
    local i ver1=($1) ver2=($2)
    # fill empty fields in ver1 with zeros
    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++))
    do
        ver1[i]=0
    done
    for ((i=0; i<${#ver1[@]}; i++))
    do
        if [[ -z ${ver2[i]} ]]
        then
            # fill empty fields in ver2 with zeros
            ver2[i]=0
        fi
        if ((10#${ver1[i]} > 10#${ver2[i]}))
        then
            return 1
        fi
        if ((10#${ver1[i]} < 10#${ver2[i]}))
        then
            return 2
        fi
    done
    return 0
}

_versions() {
	local URL="$1"
	if [[ "$URL" == "" ]]; then
		>&2 echo "This sub command requires URL as a parameter"
		return 1
	fi
	local HASH=$(_hash "$URL")
	if [[ "$HASH" != "" ]]; then
		for I in $(ipfs files ls //MiceWeb/pages/$HASH 2>/dev/null | sed 's/^/'"$HASH"'\//')
		do
			if [[ $I != *.* ]]; then
				echo $I
			fi
		done
	fi
}

_wget() {
	local URL="$1"
	local options="$2"
	local comment="$3"
	local MYTMPDIR=$(mktemp -d 2>/dev/null || mktemp -d -t 'mytmpdir')
	local MYTMPFILE=$(mktemp 2>/dev/null || mktemp -t 'mytmpfile')
	cd $MYTMPDIR
	local RAND="$(_random_value)"
	echo "Log $RAND" > $MYTMPFILE
	echo "$comment" >> $MYTMPFILE
	local USERAGENT="Mozilla/5.0 (Windows NT 10.0; rv:91.0) Gecko/20100101 Firefox/91.0"
	if [ "$options" != "--torsocks" ]; then
		wget --adjust-extension --no-cache --page-requisites --follow-ftp --restrict-file-names=windows --convert-links --backup-converted --no-host-directories --timeout=30 --tries=5 --user-agent="$USERAGENT" $options --append-output=$MYTMPFILE "$URL"
	else
		if _command_exists torsocks; then
			torsocks --isolate wget --adjust-extension --no-cache --page-requisites --follow-ftp --restrict-file-names=windows --convert-links --backup-converted --no-host-directories --timeout=30 --tries=1 --user-agent="$USERAGENT" --append-output=$MYTMPFILE "$URL"
		fi
	fi
	local WGETERR=$?
	local RET=1
	if [[ $WGETERR -eq 0 || $WGETERR -eq 8 ]] && [ $(ls -A "$MYTMPDIR" | wc -l) -ne 0 ]; then
		local CID="$(ipfs add --quieter --pin=false -r $MYTMPDIR)"
		ipfs files cp //ipfs/$CID /$SAVE_MFS_ADDR/$SUBDIR
		if [ $? -eq 0 ]; then
			local LOGCID="$(ipfs add --quieter --pin=false $MYTMPFILE)"
			ipfs files cp //ipfs/$LOGCID /$SAVE_MFS_ADDR/$SUBDIR.log
			echo "$SAVE_HASH/$SUBDIR"
			RET=0
		fi
	else
		if [ "$options" != "--torsocks" ]; then
			>&2 echo "Error: wget can't download $1 (err. $WGETERR)"
		fi
	fi
	cd ..
	rm -r $MYTMPDIR
	rm $MYTMPFILE
	return $RET
}

###############################################################################
# Subcommands
# ===========..................................................................
#
# Example subcommand group structure:
#
# describe example ""   - Optional. A short description for the subcommand.
# example() { : }   - The subcommand called by the user.
#
#
# describe example <<HEREDOC
#   Usage:
#     $_ME example
#
#   Description:
#     Print "Hello, World!"
#
#     For usage formatting conventions see:
#     - http://docopt.org/
#     - http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html
# HEREDOC
# example() {
#   printf "Hello, World!\\n"
# }
#
###############################################################################


# backup ######################################################################

describe "backup" <<HEREDOC
Usage:
  ${_ME} backup

Description:
  Backup CID of the MiceWeb Library
HEREDOC
backup() {
	mkdir --parents "$HOME/.miceweb"
	local DT=$(export TZ=GMT ; date '+%Y-%m-%d GMT %H:%M:%S')
	local CID="$(ipfs files stat --hash //MiceWeb)"
	if [[ "$CID" != "" ]]; then
		printf "%s\t%s\n" "$DT" "$CID" >> "$HOME/.miceweb/backup.txt"
		if [ $? -eq 0 ]; then
			>&2 echo "Added CID of /MiceWeb in MFS to ~/.miceweb/backup.txt"
			echo $CID
		else
			echo $CID
			_exit_1 printf "Can't backup CID to ~/.miceweb/backup.txt"
		fi
	else
		_exit_1 printf "Can't obtain CID of the MiceWeb Library"
	fi
}

# cleanup #####################################################################

describe "cleanup" <<HEREDOC
Usage:
  ${_ME} cleanup

Description:
  Cleanup service data
HEREDOC
cleanup() {
	if [[ "$1" != "" ]]; then
		>&2 echo "This subcommand doesn't require parameters"
		return 1
	fi
	local MFS_PRESENTS_ADDR="/MiceWeb/presents"
	local CID="$(ipfs files stat --hash /$MFS_PRESENTS_ADDR)"
	if [[ "$CID" == "" ]]; then
		>&2 echo "Failed to cleanup"
		return 1
	fi
	if ipfs files rm -r /$MFS_PRESENTS_ADDR; then
		>&2 echo "Removed the history of presents"
		>&2 echo ""
		>&2 echo "You can try to undo that right now by running"
		>&2 echo " 'ipfs files cp /ipfs/$CID $MFS_PRESENTS_ADDR'"
		return 0
	else
		>&2 echo "Failed to cleanup"
		return 1
	fi
}

# find ########################################################################

describe "find" <<HEREDOC
Usage:
  ${_ME} find <URL>

Description:
  Find saved web pages in ~/Downloads (use SingleFile or SingleFileZ browser extension)
HEREDOC
find() {
	>&2 _print_with_hyperlink "Install " "https://github.com/gildas-lormeau/SingleFile"
	>&2 _print_with_hyperlink " or " "https://github.com/gildas-lormeau/SingleFileZ" " browser extension,"
	>&2 echo " then set filename template to some value contains {url-href-digest-sha-1}"
	>&2 echo "Downloads folder should be inside ~/Downloads (or just create a symlink)"
	>&2 echo ""
	local URL="$(_url_but_fragment "$1")"
	if [[ "$URL" == "" ]]; then
		>&2 echo "This subcommand requires URL as a parameter"
		return 1
	fi
	if ! _check_url "$URL"; then
		>&2 echo "Supported URL prefixes: http://, https://, ftp://, ftps://, ipns://, ipfs://"
		return 1
	fi
	local filename=$(basename "$URL")
	command find -L ~/Downloads -name "$filename" -not -path '*/.*' | awk -v PREFIX="miceweb import \"$URL\" \"" -v SUFFIX="\"" '{print PREFIX $0 SUFFIX}'
	command find -L ~/Downloads -name "$filename.*" -not -path '*/.*' | awk -v PREFIX="miceweb import \"$URL\" \"" -v SUFFIX="\"" '{print PREFIX $0 SUFFIX}'
	for J in $(_similar "$URL" 2>/dev/null); do
		if [[ "$J" == http*://* ]]; then
			local HASH=$(_hash "$J")
			if [[ "$HASH" != "" ]]; then
				command find -L ~/Downloads -name "*$HASH*" -not -path '*/.*' | awk -v PREFIX="miceweb import \"$J\" \"" -v SUFFIX="\"" '{print PREFIX $0 SUFFIX}'
			fi
		fi
	done
}

# hash ########################################################################

describe "hash" <<HEREDOC
Usage:
  ${_ME} hash <URL>

Description:
  Calculate SHA-1 hash for URL (but fragment)
HEREDOC
hash() {
	local URL="$1"
	if [[ "$URL" == "" ]]; then
		>&2 echo "This subcommand requires URL as a parameter"
		return 1
	fi
	if ! _check_url "$URL"; then
		>&2 echo "Supported URL prefixes: http://, https://, ftp://, ftps://, ipns://, ipfs://"
		return 1
	fi
	_hash "$URL"
	return $?
}

# help ########################################################################

describe "help" <<HEREDOC
Usage:
  ${_ME} help [<subcommand>]

Description:
  Display help information for ${_ME} or a specified subcommand
HEREDOC
help() {
  if [[ "${1:-}" ]]
  then
    describe --get "${1}"
  else
    cat <<HEREDOC
  __  __   _                 __        __        _     
 |  \/  | (_)   ___    ___   \ \      / /  ___  | |__  
 | |\/| | | |  / __|  / _ \   \ \ /\ / /  / _ \ | '_ \ 
 | |  | | | | | (__  |  __/    \ V  V /  |  __/ | |_) |
 |_|  |_| |_|  \___|  \___|     \_/\_/    \___| |_.__/ 

Version: ${_VERSION}

Usage:
  ${_ME} <subcommand> [--subcommand-options] [<arguments>]

Help:
  ${_ME} help [<subcommand>]

$(_subcommands --)
HEREDOC
  fi
}

# history #####################################################################

describe "history" <<HEREDOC
Usage:
  ${_ME} history

Description:
  List URLs which were attempted to be saved or imported
HEREDOC
history() {
	FN="$HOME/.miceweb/history.txt"
	COUNT=$(cat $FN 2>/dev/null | wc -l)
	if [ $COUNT -ne 0 ]; then
		>&2 echo "There is a list of URLs which was attempted to be saved or imported:"
		cat $FN
		>&2 echo ""
		>&2 echo "NumEntries: $COUNT"
	else
		>&2 echo "There are no URLs which was attempted to be saved or imported"
	fi
}

# import ######################################################################

describe "import" <<HEREDOC
Usage:
  ${_ME} import <URL> <local/ipfs/ipns path>

Description:
  Import web page snapshot from file or directory
HEREDOC
import() {
	_upgrade
	URL="$1"
	IMPPATH="$2"
	COMMENT="$3"
	if [[ "$URL" == "" || "$IMPPATH" == "" ]]; then
		>&2 echo "This subcommand requires URL as a first parameter"
		>&2 echo " and local/ipfs/ipns path as a second parameter,"
		>&2 echo " some comment can be specified as a third parameter"
		return 1
	fi
	if ! _check_url "$URL"; then
		>&2 echo "Supported URL prefixes: http://, https://, ftp://, ftps://, ipns://, ipfs://"
		return 1
	fi
	_addToHistory "$URL"
	_reprovidingWarning
	HASH=$(_hash "$URL")
	if [[ "$HASH" != "" ]]; then
		MFS_ADDR="/MiceWeb/pages/$HASH"
		ipfs files ls /$MFS_ADDR/URL.txt >/dev/null 2>/dev/null
		if [ $? -ne 0 ]; then
			ipfs files mkdir //MiceWeb 2>/dev/null
			ipfs files mkdir //MiceWeb/pages 2>/dev/null
			ipfs files mkdir /$MFS_ADDR 2>/dev/null
			URLTXTCID="$(printf "%s\n%s\n" "URL $(_random_value)" "$URL" | ipfs add --quieter --pin=false)"
			ipfs files cp //ipfs/$URLTXTCID /$MFS_ADDR/URL.txt
		fi
		local DT=$(export TZ=GMT ; date '+%Y%m%dGMT%H%M%S')
		local SUBDIR="$DT-import"
		local CID=""
		local LOGTXTCID=""
		if [[ "$IMPPATH" == /ipfs/* || "$IMPPATH" == /ipns/* ]]; then
			local ADDR=""
			local RESOLVED=""
			if [[ "$IMPPATH" == /ipns/* ]]; then
				ADDR=$(ipfs name resolve --recursive=true --timeout=60s "${IMPPATH#/ipns/}")
				RESOLVED=", which resolved to $ADDR"
			else
				ADDR="$IMPPATH"
			fi
			if [[ "$ADDR" != "" ]]; then
				local ADDR2=$(ipfs resolve --timeout=60s "${ADDR#/ipfs/}")
				if [[ "$ADDR2" != "" ]]; then
					local SUBDIR0="$SUBDIR"ing
					if ipfs files cp /$ADDR2 /$MFS_ADDR/$SUBDIR0; then
						if [[ "${ADDR%/}" != "$ADDR2" ]]; then
							if [[ "$RESOLVED" == "" ]]; then
								RESOLVED=", which resolved to $ADDR2"
							else
								RESOLVED="$RESOLVED, then to $ADDR2"
							fi
						fi
						LOGTXTCID="$(printf "%s\n%s\n%s\n" "Log $(_random_value)" "Imported from $IMPPATH$RESOLVED" "$COMMENT" | ipfs add --quieter --pin=false)"
						ipfs files cp //ipfs/$LOGTXTCID /$MFS_ADDR/$SUBDIR.log
						if ipfs dag stat "${ADDR2#/ipfs/}"; then
							if ipfs files mv /$MFS_ADDR/$SUBDIR0 /$MFS_ADDR/$SUBDIR; then
								echo "$HASH/$SUBDIR"
								>&2 echo "Run 'miceweb present \"$URL\"' to view saved snapshots"
								return 0
							fi
						fi
					fi
				fi
			fi
		elif [ -e "$IMPPATH" ]; then
			if [ -d "$IMPPATH" ]; then
				CID="$(ipfs add --quieter --pin=false -r "$IMPPATH")"
			else
				CID="$(ipfs add --quieter --pin=false "$IMPPATH")"
			fi
			ipfs files cp //ipfs/$CID /$MFS_ADDR/$SUBDIR
			if [ $? -eq 0 ]; then
				local IMPPATH0=${IMPPATH%/}
				local IMPBASE=${IMPPATH0%/*}
				local IMPBASEDIR=${IMPBASE##*/}
				local IMPNAME=${IMPPATH0##*/}
				LOGTXTCID="$(printf "%s\n%s\n%s\n" "Log $(_random_value)" "Imported from $IMPBASEDIR/$IMPNAME" "$COMMENT" | ipfs add --quieter --pin=false)"
				ipfs files cp //ipfs/$LOGTXTCID /$MFS_ADDR/$SUBDIR.log
				echo "$HASH/$SUBDIR"
				>&2 echo "Run 'miceweb present \"$URL\"' to view saved snapshots"
				return 0
			fi
		else
			>&2 echo "Error: $IMPPATH not found"
		fi
	fi
	return 1
}

# present #####################################################################

describe "present" <<HEREDOC
Usage:
  ${_ME} present <URL>
  ${_ME} present url <SHA-1 hash>
  ${_ME} present urls [--grep=<expression>] [<local file path>]
  ${_ME} present

Description:
  Present saved versions of web page(s) by URL(s)
HEREDOC
present() {
	_upgrade
	if [[ "$1" == "urls" ]]; then
		if [[ "$2" != "" ]]; then
			ipfs files mkdir //MiceWeb 2>/dev/null
			ipfs files mkdir //MiceWeb/presents 2>/dev/null
			local DT=$(export TZ=GMT ; date '+%Y%m%dGMT%H%M%S')
			local MFS_PRESENT_ADDR="/MiceWeb/presents/present-$DT"
			ipfs files mkdir /$MFS_PRESENT_ADDR 2>/dev/null
			local COUNT=0
			local HASH=""
			for I in $("$0" "$@" 2>/dev/null)
			do
				HASH=$(_hash "$I")
				ipfs files cp //MiceWeb/pages/$HASH /$MFS_PRESENT_ADDR/$HASH 2>/dev/null
				if [ $? -eq 0 ]; then
					((COUNT++))
				fi
				#TODO: or with similar (maybe support --similar option)
				#for J in $(_similar "$I" 2>/dev/null)
				#do
				#	local HASH=$(_hash "$J")
				#	ipfs files cp //MiceWeb/pages/$HASH /$MFS_PRESENT_ADDR/$HASH 2>/dev/null
				#	if [ $? -eq 0 ]; then
				#		((COUNT++))
				#	fi
				#done
				if _has_url_fragment "$I"; then
					HASH=$(_hash_string "$I")
					ipfs files cp //MiceWeb/pages/$HASH /$MFS_PRESENT_ADDR/$HASH 2>/dev/null
					if [ $? -eq 0 ]; then
						((COUNT++))
					fi
				fi
			done
			local CID="$(ipfs files stat --hash /$MFS_PRESENT_ADDR)"
			if [[ "$CID" != "" && $COUNT -ne 0 ]]; then
				local GATEWAY=$(ipfs config Addresses.Gateway)
				if [ $? -eq 0 ]; then
					>&2 _print_with_hyperlink "Open " "http://127.0.0.1:${GATEWAY##*/}/ipfs/$CID" " in a browser on the local machine"
					>&2 echo ""
				fi
				if [[ "$REPROVIDING" != "all" ]]; then
					>&2 echo "If you need to publish or view from an other machine,"
					>&2 echo " run 'ipfs pin add $CID'"
					if [[ "$REPROVIDING" == "roots" ]]; then
						>&2 echo " and 'ipfs config Reprovider.Strategy pinned'"
					fi
					>&2 echo ""
				fi
				echo "/ipfs/$CID"
				local STAT=$", NumURLs: $COUNT"
				ipfs dag stat $CID | awk -v SUFFIX="$STAT" '{print $0 SUFFIX}' 1>&2
				#TODO: rename *-importing to *-import
				return 0
			fi
		else
			present
			return $?
		fi
		#TODO: fix and implement something like >&2 echo "Run 'miceweb save ${@@Q}'"
		return 1
	fi
	if [[ "$1" == "url" ]]; then
		if [[ "$2" != "" ]]; then
			URL=$(url "$2")
			if [[ "$URL" != "" ]]; then
				present "$URL"
				if [ $? -eq 0 ]; then
					return 0
				#else
					#>&2 echo "Run 'miceweb save ""$URL""'"
				fi
			fi
		else
			url
		fi
		return 1
	fi
	
	local URL="$1"
	local HASH=""
	local CID0=""
	local CID=""
	local CNT=0
	local URL0="$(_url_but_fragment "$URL")"
	local SIMURL="$URL0"
	
	if [[ "$URL" != "" ]]; then
		HASH=$(_hash "$URL" 2>/dev/null)
	fi

	if [[ "$HASH" != "" ]]; then
		local MFS_PAGE_ADDR="/MiceWeb/pages/$HASH"
		ipfs files ls /$MFS_PAGE_ADDR/URL.txt >/dev/null 2>/dev/null
		if [ $? -ne 0 ]; then
			if _check_url "$URL"; then
				ipfs files mkdir //MiceWeb 2>/dev/null
				ipfs files mkdir //MiceWeb/pages 2>/dev/null
				ipfs files mkdir /$MFS_PAGE_ADDR 2>/dev/null
				local URLTXTCID="$(printf "%s\n%s\n" "URL $(_random_value)" "$URL" | ipfs add --quieter --pin=false)"
				ipfs files cp //ipfs/$URLTXTCID /$MFS_PAGE_ADDR/URL.txt
			else
				>&2 echo "Supported URL prefixes: http://, https://, ftp://, ftps://, ipns://, ipfs://"
				return 1
			fi
		fi
		ipfs files mkdir //MiceWeb 2>/dev/null
		ipfs files mkdir //MiceWeb/presents 2>/dev/null
		local DT=$(export TZ=GMT ; date '+%Y%m%dGMT%H%M%S')
		local MFS_PRESENT_ADDR="/MiceWeb/presents/present-$DT"
		ipfs files mkdir /$MFS_PRESENT_ADDR 2>/dev/null
		for I in $(_similar "$URL" 2>/dev/null)
		do
			local SIMHASH=$(_hash "$I")
			if ipfs files cp //MiceWeb/pages/$SIMHASH /$MFS_PRESENT_ADDR/$SIMHASH 2>/dev/null; then
				if [[ "$I" != "$URL0" ]]; then
					SIMURL="$I"
				fi
				((CNT++))
			fi
		done
		if _has_url_fragment "$URL"; then
			local SIMHASH=$(_hash_string "$URL")
			if ipfs files cp //MiceWeb/pages/$SIMHASH /$MFS_PRESENT_ADDR/$SIMHASH 2>/dev/null; then
				((CNT++))
			fi
		fi
		CID0="$(ipfs files stat --hash /$MFS_PRESENT_ADDR)"
		CID="$CID0/$HASH"
	else
		local MFS_PRESENT_ADDR="/MiceWeb/pages/"
		CID0="$(ipfs files stat --hash /$MFS_PRESENT_ADDR)"
		CID="$CID0"
	fi
	
	if [[ "$CID" != "" ]]; then
		local GATEWAY=$(ipfs config Addresses.Gateway)
		if [ $? -eq 0 ]; then
			local PAYATT=""
			# "might be"... yeah, AI wants to rest too
			if [ $CNT -gt 2 ]; then
				PAYATT=" (also, there might be snapshots for similar URLs)"
			elif [ $CNT -gt 1 ]; then
				if [[ "$SIMURL" != "$URL0" ]]; then
					PAYATT=" (also, there might be snapshots for $SIMURL)"
				else
					PAYATT=" (also, there might be snapshots for a similar URL)"
				fi
			fi
			>&2 _print_with_hyperlink "Open " "http://127.0.0.1:${GATEWAY##*/}/ipfs/$CID" " in a browser on the local machine$PAYATT"
			>&2 echo ""
		fi
		local REPROVIDING=$(ipfs config Reprovider.Strategy)
		if [[ "$1" != "" ]]; then
			if [[ "$REPROVIDING" != "all" ]]; then
				>&2 echo "If you need to publish or view from an other machine,"
				>&2 echo " run 'ipfs pin add $CID0'"
				if [[ "$REPROVIDING" == "roots" ]]; then
					>&2 echo " and 'ipfs config Reprovider.Strategy pinned'"
				fi
				>&2 echo ""
			fi
		else
			>&2 echo "There is a content identifier of current pages of all the MiceWeb Library"
			>&2 echo "It's not recommended to share it because security and other reasons,"
			>&2 echo " however, if you need it, pin $CID0"
			if [[ "$REPROVIDING" == "roots" ]]; then
				>&2 echo " and run 'ipfs config Reprovider.Strategy pinned'"
			fi
			>&2 echo ""
		fi
		echo "/ipfs/$CID"
		local STAT=""
		local COUNT=0
		if [[ $HASH != */* ]]; then
			if [[ "$HASH" == "" ]]; then
				COUNT=$(ipfs files ls //MiceWeb/pages | grep ^[0-9a-f] | wc -l)
				STAT=$", NumURLs: $COUNT"
			else
				for I in $(ipfs files ls //MiceWeb/pages/$HASH); do
					if [[ $I != *.* ]]; then
						((COUNT++))
					fi
				done
				STAT=$", NumVersions: $COUNT"
			fi
		fi
		#TODO: rename *-importing to *-import
		ipfs dag stat $CID | awk -v SUFFIX="$STAT" '{print $0 SUFFIX}' 1>&2
	else
		>&2 echo "Run 'miceweb save ${@@Q}'"
		exit 1
	fi
}

# save ########################################################################

describe "save" <<HEREDOC
Usage:
  ${_ME} save <URL>
  ${_ME} save url <SHA-1 hash>
  ${_ME} save urls [--grep=<expression>] [<local file path>]

Description:
  Save web page snapshot(s)
HEREDOC
save() {
	_upgrade
	#TODO: --archives={default|none|last|set}
	if [[ "$1" == "urls" ]]; then
		_reprovidingWarning
		for I in $("$0" "$@" 2>/dev/null)
		do
			if _check_url "$I"; then
				local VERSIONS_COUNT=$(_versions "$I" | grep -e "^.*-wget$" -e "^.*-ip.s$" | wc -l)
				if [ "$VERSIONS_COUNT" -eq 0 ]; then
					if ! _check_free_space_for_temp
					then
						>&2 echo "Free disk space for temporary files and run the command again"
						return 1
					fi
					>&2 echo -n "Saving $I"
					local rnumber=$((RANDOM%11+5))
					for (( i = 1; i <= $rnumber; i++ )) ; do
						sleep 1
						>&2 echo -n "."
					done
					>&2 echo ""
					save --no-warnings "$I"
				fi
			fi
		done
		#TODO: fix and implement something like >&2 echo "Run 'miceweb present $@' to view saved snapshots"
		return 0
	fi
	local URL=""
	if [[ "$1" == "url" ]]; then
		if [[ "$2" != "" ]]; then
			URL=$(url "$2")
			if [[ "$URL" != "" ]]; then
				save "$URL"
				return $?
			fi
		else
			url
		fi
		return 1
	fi
	local _arguments=()
	local _warnings=1
	local _val=
	for __arg in "${@:-}"
	do
	case ${__arg} in
	  --no-warnings)
		_warnings=0
		;;
	  -*)
		_exit_1 printf "Unexpected option: %s\\n" "${__arg}"
		;;
	  *)
		if _blank "${_URL}"
		then
		  _val="${__arg}"
		  URL="$_val"
		else
		  _arguments+=("${__arg}")
		fi
		;;
	esac
	done
	if [[ "$URL" == "" ]]; then
		>&2 echo "This subcommand requires URL as a parameter"
		return 1
	fi
	if ! _check_url "$URL"; then
		>&2 echo "Supported URL prefixes: http://, https://, ftp://, ftps://, ipns://, ipfs://"
		return 1
	fi
	_addToHistory "$URL"
	type -P wget &>/dev/null && ISINST=1 || ISINST=0
	if [ $ISINST -eq 0 ]
	then
		>&2 echo "Error: wget is not installed"
		return 127
	fi
	if [ $_warnings -eq 1 ]; then
		_reprovidingWarning
	fi
	local URL0=$(_url_but_fragment "$URL")
	SAVE_HASH=$(_hash "$URL")
	if [[ "$SAVE_HASH" != "" ]]; then
		SAVE_MFS_ADDR="/MiceWeb/pages/$SAVE_HASH"
		ipfs files ls /$SAVE_MFS_ADDR/URL.txt >/dev/null 2>/dev/null
		if [ $? -ne 0 ]; then
			ipfs files mkdir //MiceWeb 2>/dev/null
			ipfs files mkdir //MiceWeb/pages 2>/dev/null
			ipfs files mkdir /$SAVE_MFS_ADDR 2>/dev/null
			local URLTXTCID="$(printf "%s\n%s\n" "URL $(_random_value)" "$URL0" | ipfs add --quieter --pin=false)"
			ipfs files cp //ipfs/$URLTXTCID /$SAVE_MFS_ADDR/URL.txt
		fi
		if _check_free_space_for_temp
		then
			if [[ $URL == ipns://* ]]; then
				_save_ipns "${URL#ipns://}"
			elif [[ $URL == ipfs://* ]]; then
				_save_ipfs "${URL#ipfs://}"
			else
				_save_wget $URL
				if [ $? -ne 0 ]; then
					_save_archived $URL
				fi
			fi
			PARSEDPATH=$(_parse_path $URL)
			if [[ $URL == http*://*.*/ipfs/* ]]; then
				_save_ipfs "${PARSEDPATH#/ipfs/}"
			elif [[ $URL == http*://*.*/ipns/* ]]; then
				_save_ipns "${PARSEDPATH#/ipns/}"
			fi
			if [ $_warnings -eq 1 ]; then
				>&2 echo "Run 'miceweb present \"$URL0\"' to view saved snapshots"
			fi
		else
			>&2 echo "Error: insufficient disk space for temporary files"
			return 1
		fi
	else
		return 1
	fi
}

# subcommands #################################################################

describe "subcommands" <<HEREDOC
Usage:
  ${_ME} subcommands

Description:
  Display the list of available subcommands
HEREDOC
subcommands() {
	_subcommands --raw $1
}

# remove ######################################################################

describe "remove" <<HEREDOC
Usage:
  ${_ME} remove <URL>

Description:
  Remove all saved snapshots of web page by URL
HEREDOC
remove() {
	_upgrade
	local URL="$1"
	if [[ "$URL" == "" ]]; then
		>&2 echo "This subcommand requires URL as a parameter"
		return 1
	fi
	local HASH=$(_hash "$URL")
	if [[ "$HASH" != "" ]]; then
		local MFS_PAGE_ADDR="/MiceWeb/pages/$HASH"
		if ipfs files ls /$MFS_PAGE_ADDR >/dev/null; then
			local CID="$(ipfs files stat --hash /$MFS_PAGE_ADDR)"
			if [[ "$CID" != "" ]]; then
				local CACHE_DIR="$HOME/.miceweb/cache/urls/"
				if [ -e "$CACHE_DIR$HASH" ]; then
					rm "$CACHE_DIR$HASH"
				fi
				ipfs files rm -r /$MFS_PAGE_ADDR
				if [ $? -eq 0 ]; then
					>&2 echo "Removed $URL from the MiceWeb Library"
					>&2 echo ""
					>&2 echo "You can try to undo that right now by running"
					>&2 echo " 'ipfs files cp /ipfs/$CID $MFS_PAGE_ADDR'"
					>&2 echo ""
					>&2 echo "Also, look into 'miceweb cleanup'"
					return 0
				fi
			fi
		fi
	fi
	return 1
}

# url #########################################################################

describe "url" <<HEREDOC
Usage:
  ${_ME} url <SHA-1 hash>

Description:
  Return URL by SHA-1 hash
HEREDOC
url() {
	_upgrade
	if [[ "$1" == "" ]]; then
		>&2 echo "This subcommand requires SHA-1 hash as a parameter"
		return 1
	fi
	local CACHE_FILE="$HOME/.miceweb/cache/urls/$1"
	local URL=$(grep "" "$CACHE_FILE" 2>/dev/null)
	if [[ "$URL" != "" ]]; then
		local HASH=$(_hash "$URL")
		if [[ "$1" == "$HASH" ]]; then
			echo "$URL"
			return 0
		fi
	fi
	URL=$(ipfs files read //MiceWeb/pages/$1/URL.txt | sed -n 2p)
	if [[ "$URL" != "" ]]; then
		local HASH=$(_hash "$URL")
		if [[ "$1" == "$HASH" ]]; then
			echo "$URL" > "$CACHE_FILE"
			echo "$URL"
			return 0
		fi
	fi
	return 1
}

# urls ########################################################################

describe "urls" <<HEREDOC
Usage:
  ${_ME} save urls [--grep=<expression>] [<local file path>]

Description:
  List URLs from file (text or json or html) or from the MiceWeb Library
HEREDOC
urls() {
	_upgrade
	local FIL=""
	local PARAM=""
	local GREP=""
	local BASE=""
	for I in "$@"; do
		if [[ $I == "--grep" ]]; then
		  	PARAM="grep"
		elif [[ $I == "--base" ]]; then
		  	PARAM="base"
		else
			if [[ $PARAM == "grep" ]]; then
				GREP=$I
			elif [[ $PARAM == "base" ]]; then
				BASE=$I
			else
				FIL=$I
			fi
			PARAM=""
		fi
	done
	if [[ "$FIL" == "" ]]; then
		>&2 echo "This subcommand requires file as a parameter:"
		>&2 echo " txt - contain URLs in separate lines"
		>&2 echo " json - contain URLs in the 'url' field"
		>&2 echo " html - contain URLs in the 'href' attribute"
		>&2 echo ""
		local CID="$(ipfs files stat --hash //MiceWeb/pages/)"
		if [[ "$CID" != "" ]]; then
			>&2 echo "There are URLs already in the MiceWeb Library (see also 'miceweb history'):"
			local CACHE_DIR="$HOME/.miceweb/cache/urls/"
			mkdir --parents "$CACHE_DIR"
			for I in $(ipfs files ls //MiceWeb/pages/ | grep ^[0-9a-f]); do
				local CACHE_FILE="$CACHE_DIR$I"
				local URL=$(grep "" "$CACHE_FILE" 2>/dev/null)
				if [[ "$URL" != "" ]]; then
					echo "$URL" | grep "$GREP"
				else
					URL=$(ipfs cat $CID/$I/URL.txt 2>/dev/null | sed -n 2p)
					if [[ "$URL" != "" ]]; then
						echo "$URL" > "$CACHE_FILE"
						echo "$URL" | grep "$GREP"
					else
						>&2 echo "Error: $I not resolved"
					fi
				fi
			done
			>&2 echo ""
		fi
		return
	fi
	if [[ $FIL == *.json ]]; then
		type -P jq &>/dev/null && ISINST=1 || ISINST=0
		if [ $ISINST -eq 0 ]
		then
			>&2 _print_with_hyperlink "Error: jq is not installed (seeing " "https://stedolan.github.io/jq/download/" ")"
			exit 127
		fi
		if [[ "$BASE" != "" ]]; then
			>&2 echo "Attribute --base is only supported for html files"
			exit 1
		fi
		cat $FIL | jq --raw-output '.. | .url? | strings' | grep "$GREP" | awk '!a[$0]++; fflush()'
	elif [[ $FIL == *.htm* ]]; then
		type -P htmlq &>/dev/null && ISINST=1 || ISINST=0
		if [ $ISINST -eq 0 ]
		then
			>&2 _print_with_hyperlink "Error: htmlq is not installed (seeing " "https://github.com/mgdm/htmlq/" ")"
			exit 127
		fi
		if [[ "$BASE" != "" ]]; then
			cat $FIL | htmlq --base="$BASE" --attribute href a | grep "$GREP" | awk '!a[$0]++; fflush()'
		else
			cat $FIL | htmlq --detect-base --attribute href a | grep "$GREP" | awk '!a[$0]++; fflush()'
		fi
	else
		if [[ "$BASE" != "" ]]; then
			>&2 echo "Attribute --base is only supported for html files"
			exit 1
		fi
		grep "$GREP" $FIL | awk '!a[$0]++; fflush()'
	fi
}

# version #####################################################################

describe "version" <<HEREDOC
Usage:
  ${_ME} version

Description:
  Display the current program version

  To save you the trouble, the current version is ${_VERSION}
HEREDOC
version() {
  printf "%s\\n" "${_VERSION}"
}


###############################################################################
# Run Program
###############################################################################

# Call the `_main` function after everything has been defined.
_main
